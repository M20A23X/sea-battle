name: Server CI/CD

on:
  workflow_dispatch:
  push:
    branches: [ 'master', 'dev' ]
    paths:
      - 'packages/server/**'
  pull_request:
    branches: [ 'master', 'dev' ]
    paths:
      - 'packages/server/**'

env:
  SERVER_CONTAINER: server
  SERVER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:server
  SERVER_PORT_HTTP: ${{ secrets.DOCKER_NETWORK_SERVER_PORT_HTTP }}
  SERVER_PORT_WS: ${{ secrets.DOCKER_NETWORK_SERVER_PORT_WS }}
jobs:
  ci:
    name: Server CI
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Create Docker network
        run: |
          docker network create \
            --driver bridge \
            --subnet ${{ secrets.DOCKER_NETWORK_SUBNET }} \
            --gateway ${{ secrets.DOCKER_NETWORK_GATEWAY }} \
            --ip-range ${{ secrets.DOCKER_NETWORK_IP_RANGE }} \
            ${{ secrets.DOCKER_NETWORK }}

      - name: Build test server image
        run: |
          docker build \
          --file docker/configs/server/Dockerfile.test \
          --tag ${SERVER_IMAGE}-test \
          --build-arg PORT_HTTP=$SERVER_PORT_HTTP \
          --build-arg PORT_WS=$SERVER_PORT_WS \
          .

      - name: Run server test
        run: |
          docker run \
            --name ${SERVER_CONTAINER}-test \
            --publish $SERVER_PORT_HTTP:$SERVER_PORT_HTTP \
            --publish $SERVER_PORT_WS:$SERVER_PORT_WS \
            --net "${{ secrets.DOCKER_NETWORK }}" \
            --ip "${{ secrets.DOCKER_NETWORK_SERVER_IP }}" \
            --env NODE_ENV=testing \
            --env APP_ID="${{ vars.APP_ID }}" \
            --env APP_NAME="${{ vars.APP_NAME }}" \
            --env SERVER_JWT_CONFIRMATION_SECRET="${{ secrets.SERVER_JWT_CONFIRMATION_SECRET }}" \
            --env SERVER_JWT_RESET_PASSWORD_SECRET="${{ secrets.SERVER_JWT_RESET_PASSWORD_SECRET }}" \
            --env SERVER_JWT_REFRESH_SECRET="${{ secrets.SERVER_JWT_REFRESH_SECRET }}" \
            --env SERVER_JWT_ACCESS_PUBLIC_KEY="${{ secrets.SERVER_JWT_ACCESS_PUBLIC_KEY }}" \
            --env SERVER_JWT_ACCESS_PRIVATE_KEY="${{ secrets.SERVER_JWT_ACCESS_PRIVATE_KEY }}" \
            --env SERVER_JWT_CONFIRMATION_EXPIRATION_MS="${{ vars.SERVER_JWT_CONFIRMATION_EXPIRATION_MS }}" \
            --env SERVER_JWT_RESET_PASSWORD_EXPIRATION_MS="${{ vars.SERVER_JWT_RESET_PASSWORD_EXPIRATION_MS }}" \
            --env SERVER_JWT_REFRESH_EXPIRATION_MS="${{ vars.SERVER_JWT_REFRESH_EXPIRATION_MS }}" \
            --env SERVER_JWT_ACCESS_EXPIRATION_MS="${{ vars.SERVER_JWT_ACCESS_EXPIRATION_MS }}" \
            --env SERVER_EMAIL_HOST="${{ secrets.SERVER_EMAIL_HOST }}" \
            --env SERVER_EMAIL_PORT="${{ secrets.SERVER_EMAIL_PORT }}" \
            --env SERVER_EMAIL_USERNAME="${{ secrets.SERVER_EMAIL_USERNAME }}" \
            --env SERVER_EMAIL_PASSWORD="${{ secrets.SERVER_EMAIL_PASSWORD }}" \
            --env SERVER_PUBLIC_FILE_MAX_SIZE_B="${{ vars.SERVER_PUBLIC_FILE_MAX_SIZE_B }}" \
            --env SERVER_PUBLIC_ALLOWED_EXTENSIONS="${{ vars.SERVER_PUBLIC_ALLOWED_EXTENSIONS }}" \
            --env SERVER_HEALTH_DISK_THRESHOLD_PERCENT="${{ vars.SERVER_HEALTH_DISK_THRESHOLD_PERCENT }}" \
            --env SERVER_HEALTH_MEM_HEAP_THRESHOLD_B="${{ vars.SERVER_HEALTH_MEM_HEAP_THRESHOLD_B }}" \
            --env SERVER_HEALTH_MEM_RSS_THRESHOLD_B="${{ vars.SERVER_HEALTH_MEM_RSS_THRESHOLD_B }}" \
            --env DATABASE_HOST="${{ secrets.DATABASE_HOST }}" \
            --env DATABASE_PORT="${{ secrets.DATABASE_PORT }}" \
            --env DATABASE_USERNAME="${{ secrets.DATABASE_USERNAME }}" \
            --env DATABASE_PASSWORD="${{ secrets.DATABASE_PASSWORD }}" \
            --env DATABASE_NAME="${{ secrets.DATABASE_NAME }}" \
            --env DATABASE_PASSWORD_SECRET="${{ secrets.DATABASE_PASSWORD_SECRET }}" \
            --env DATABASE_CONNECTION_CHECK_TIMEOUT_MS="${{ vars.DATABASE_CONNECTION_CHECK_TIMEOUT_MS }}" \
            --env FE_ORIGIN=http://"${{ secrets.CLIENT_HOST }}":"${{ secrets.CLIENT_PORT }}" \
            --env SPECS_HOOK_TIMEOUT_MS="${{ vars.SPECS_HOOK_TIMEOUT_MS }}" \
            ${SERVER_IMAGE}-test
  cd:
    name: Server CD
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    needs: ci
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Build production server image
        run: |
          docker build \
            --file docker/configs/server/Dockerfile.prod \
            --tag "${SERVER_IMAGE}-prod" \
            --build-arg PORT_HTTP=$SERVER_PORT_HTTP \
            --build-arg PORT_WS=$SERVER_PORT_WS \
            .

      - name: Login to DockerHub registry
        run: echo ${{ secrets.DOCKERHUB_PASSWORD }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

      - name: Push production server image
        run: docker push "${SERVER_IMAGE}-prod"

      - name: Pull and run server image on remote host
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USERNAME }}
          password: ${{ secrets.SSH_PASSWORD }}
          envs:
            SERVER_IMAGE,
            SERVER_CONTAINER,
            SERVER_PORT_HTTP,
            SERVER_PORT_WS
          script: |
            set -e
            export SERVER_IMAGE_PROD="${SERVER_IMAGE}-prod"
            export OLD_IMAGE_ID=$(docker images -q $SERVER_IMAGE_PROD)$(echo "fallback")
            
            echo ${{ secrets.DOCKERHUB_PASSWORD }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin
            docker pull $SERVER_IMAGE_PROD
            
            docker stop $SERVER_CONTAINER || true
            docker container rm -f $SERVER_CONTAINER
            docker image rm -f $OLD_IMAGE_ID
            
            docker run -dit \
              --restart unless-stopped \
              --name $SERVER_CONTAINER \
              --publish $SERVER_PORT_HTTP:$SERVER_PORT_HTTP \
              --publish $SERVER_PORT_WS:$SERVER_PORT_WS \
              --net ${{ secrets.DOCKER_NETWORK }} \
              --ip ${{ secrets.DOCKER_NETWORK_SERVER_IP }} \
              --env NODE_ENV=production \
              --env-file $(pwd)/env/server/.env \
              $SERVER_IMAGE_PROD

            docker ps
